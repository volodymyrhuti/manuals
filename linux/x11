                                   X Protocol
=========================================================================================================
The X protocol specifies what makes up each packet of information that gets transferred between the server
and Xlib in both directions. Type of protocol packets:
- requests => generated by Xlib and sent to the server
- replies => sent from server in response to request
  Routine that requires a reply is called a round-trip request
- events
- errors

All requests are buffered and sends on next conditions =>
- application calls Xlib routine to wait for an event but no matching event is currently
  available on Xlib`s queue
- Xlib makes request that requires an response
- requests can be flushed manually in situations where no user events and no calls to query
  the server are expected (like in game, user may be idle but we need to update a picture)

To reduce network traffic, X will allocate resources on server side and label it with an id. This id is
returned to client on resource allocations request (like window,font,widget...).  Therefore instead of
sending entire data structure, client sends small identifier for object.  If any client knows ID of a
resource, that client can manipulate that resource even if some other client created the resource, this is
how window managers are implemented => they can move and resize applications windows because they know the
IDs.

Colormap => a table that maps pixel value to color, there is always at least one hardware colormap, entries
in which are named colorcells. When client has special requirements, X allows them to have private colorcells
or to create virtual colormaps which are then swapped into the hardware colormap (if it is writable) when
necessary. Colormap is a window attribute.

The number of bits per pixel is also referred as the number of planes in the graphics display. Color displays
have from 4 to 28 planes and gray-scale usually have from 2 to 4 planes.

The depth is th enumber of planes that are to be used to represent color within a window, it is also the
number of bits per pixel.

A pixmap is an array of pixel values, block of off-screen memory in the server, is valid destination for
drawing. Windows and pixmaps are collectively known as drawables. It has a depth like a window, but doesnt
have a position relative to any other window or pixmap, window attributes such as a colormap. All these
attributes affect pixmap only when it is copied to window and becomes visible.

Windows have the disadvantage that, when they are visible, drawing to them will not do anything. A pixmap
which represents an area of the screen, resides in memory and can be drawn to at any time. Unnfortunately,
pixmaps must be copied into a visible window before the user can see them, aswell memory in the server for
pixmaps may be limited.

Bitmap => a pixmap of depth 1, two-dimensional array of bits used for many purposes including cursor
definitions, fonts, and templates for two-color pictures. Each bit represent a single pixel value that is
either set (1) or unset (0)


=========================================================================================================
                              Properties and Atoms
=========================================================================================================
A property is a packet of information associated with a window, made available to all the clients
running under a server. Properties are used by clients to store information that other clients might
need or want to know and to read that infromation when set by other clients.

Properties have a string name and a numeric identifier called an atom. An atom is and ID that uniquely
identifies a particular property. Property strings are usually uppercase with undescores between words
like "WM_COLORMAP_WINDOWS". Atoms are used to refer to props in route calls so arbitrary length property
name strings do not need to be send over the network. To get atom from name, call `XInternAtom(#name)`,
from this pont application uses only the atom to refer to that property.

Some atoms are defined when server initializes and there is no need to call `XInternAtom(#name)`, instead
they are available as symbolic constants beginning with XA_ like XA_WM_HINTS. These atoms identify 
conventional properties and are known to all clients.

Window manager => daemon utility, that tracks window overlaying, focus, changes window size and position
using mouse and keyboard

Much of the communication between clients and the window manager and vice versa occurs through properties
(the rest occuring through events). Many of the properties are known as hints because they may not necessarily
be honored by the WM therefore an application must be prepared for the window manager to ignore modify
or honor the preferences it indicates through the WM hints.


=========================================================================================================
                                   Selection
=========================================================================================================
X clients need to deal with three selections
1.Primary. Typically used used by terminals when selection text and pasting with middle mouse button
  Used for the currently selected text, even if it is not explicitly copied, and for middle-mouse-click
  pasting.
2.Secondary. It does not have a consensually agreed upon purpose.
3.Clipboard. Primarily used in conection with MS Windows-style clipboard operations. Select+Copy.
  Used for explicit copy/paste commands involving keyboard shortcuts or meny items. Unlike PRIMARY, it
  can also handle multiple data formats.

There is as well drag and drop which is part of Xdnd protocol, it uses XdndSelection

It is also important to realize that according to the selection protocols, nothing is copied until it is
pasted. For example, if you select some word in a terminal window, close the terminal and then want to
paste it somewhere else, it will not work because the terminal is gone and the text has not been copied
anywhere. If you want the word to be preserved after closing terminal window, consider installing a
clipboard manager.
---------------------------------------------------------------------------------------------------------
                               Syncing Selections
---------------------------------------------------------------------------------------------------------
$ autocutsel &
$ autocutsel -s PRIMARY &
---------------------------------------------------------------------------------------------------------
https://wiki.archlinux.org/index.php/Clipboard
https://tronche.com/gui/x/icccm/sec-2.html#s-2.6.1
http://www.cs.man.ac.uk/~lindsec/secondary-selection.html
https://unix.stackexchange.com/questions/139191/whats-the-difference-between-primary-selection-and-clipboard-buffer
=========================================================================================================
                                Video Driver
=========================================================================================================
In Linux, there is two parts for the video driver, the kernel part and the X server part.
To detect video drived and kernel modules used issue
lspci -k | grep -EA3 'VGA|3D|Display'


=========================================================================================================
                        Screen vs Display vs Monitor
=========================================================================================================

=========================================================================================================
                                   Compositor
=========================================================================================================

=========================================================================================================
                                  Framebuffer
=========================================================================================================


=========================================================================================================
                            KMS(Kernel Mode Setting)
=========================================================================================================
KMS ia method for setting display resolution and depth in the kernle space rather than user space.


=========================================================================================================
                                Xorg vs Wayland
=========================================================================================================
X.Org Server is the free and open source implementation of the display server for the X Window System
stewarded by the X.Org Foundation. Wayland is a protocol that specifies the communication between a display
server (called a Wayland compositor) and its clients.
The botleneck of X server is that it doesn`t know which client should receive event and which doesnt

Even though Wayland eliminates most of the design flaws of the Xorg it has its own issues. In order to
communicate with the display server the programs, which act as clients, running on the system must know
how to communicate with it. Xorg being older than Wayland is more developed and has better extensibility.
This is the reason why some applicatons or programs might not run when using Wayland.
Wayland is not very stable when compared with Xorg, as it is relatively new.

https://www.secjuice.com/wayland-vs-xorg/
=========================================================================================================
                                  X11 Session
=========================================================================================================
X11 consists of an X server and several clients. If you start server without client you will get a black
screen. To launch X11 issue `startx` which will provide some defaul environment. Starx will look for
configuration files like ~/.Xresources ~/.Xmodmap ... and load them (check startx script to find out
which one) after starting xinit. Xinit only looks for .xinitrc therefore you don`t have to remember
difference between .Xresources .xrdb and so on.

To start some graphical utility with xinit issue `xinit <util_path>`, note that path should contain `/`
otherwise it will be considered as flag. This will start X server and client <util> which can be used
to start more X clients. Some custom Desktop environments may have custom init scripts like startkde
for KDE. 

To check if you are running X11 session or Wayland issue
echo $XDG_SESSION_TYPE

https://askubuntu.com/questions/150487/what-happens-under-the-covers-to-log-me-in-and-start-up-unity-or-another-graphic
https://en.wikibooks.org/wiki/Guide_to_X11/Starting_Sessions
=========================================================================================================
   Window Manager vs Login Manager vs Display Manager vs Desktop Environment
=========================================================================================================
Display server => creates the graphical environment. Xorg, X11, XFree86. It runs over some framework that
provides means to manipulate graphics, the main framework used for Linux is X. X provides the basic framework
for a GUI environment: drawing and moving windows on the display device and interacting with a mouse and
keyboard. X does not mandate the user interface – this is handled by individual programs.
Commonly known display server communications protocols include X11, Wayland, Mir etc.

Display/Login manager ([gkx]dm) => first program run by the system if the system (not user) is starting X
and allows you to log on to the locat system, or network systems. It may start X servers, user sessions
and greeter(login screen). Examples include:
GDM     ## Gnome display manager
LightDM ## Cross-desktop display manager
LXDM    ## Lxde display manager
SDDM    ## QML-based display manager and successor to KDE4`s kdm
SLiM    ## Lightweight graphical login solution
XDM     ## X display manager with support for XDMCP
Path to default DM is saved to /etc/X11/default-display-manager
To open greeter or lock screen from DM cli, check dm-tool utility

Window manager => controls placement and decoration of windows  Some of these are stand alone (i3,awesome)
Some depend on an accomplaying desktop environment. There are three types of WMs:
1. Floating - window overlaps.
   Windows are independent and you can resize/move them freely around your desktop.
2. Tiling - windows are arranged in tiles (like a grid)
   Windows are arranged depending on what is currently on your desktop. The windows can`t overlap.
   When you create a new window, whole set of window is rearranging to let the window find a place
3. Dynamics - both floating and tiling are possible
   Usually tiling with poor floating support
Note, that well written apps can be started without a window manager(well written?), but most of apps will
not beahve correctly. Some applications may try to simulate click on them selfs to get focus on startup.
There is option execute xinitrs? with gui app as argument, which will draw gui for it.
WM is just another X client, which gives flexibility to change it whenever you want.

Desktop environment (XFCE, KDE, GNOME) => suites of applications designed to integrate well witch each
other to provide a consistent experience. A desktop environment typically consists of icons, windows,
toolbars, folders, wallpapers and desktop widgets, might also provide drag and drop functionality and
other features. Examples =>
Unity         ## the default desktop for Ubuntu, and is one of the major desktop environments.
Gnome         ## other of the major desktop environments.
KDE           ## other of the major desktop environments.
Xfce          ## a much lighter desktop environment.
LXDE          ## arguably the lightest option available for a desktop environment.
Cinnamon      ## another alternative to Gnome.
MATE          ## a continuation of the Gnome 2 codebase.
Budgie        ## the default desktop of Solus Operating System.
Moksha        ## a continuation of the Enlightenment 17 desktop.
Enlightenment ## started as a project to build a desktop environment.
Pantheon      ## the project developed by the elementaryOS team.
Trinity       ## a continuation of the KDE 3 series.
There are two main Desktop Environments used on Linux: GNOME and KDE. GNOME is close to OS X and KDE 3.x
is close to Windows XP, KDE 4.x is close to Windows Vista

To check which DE you are using issue one of the followng:
ls /usr/bin/*session   # 
To check WM issue
echo $DESKTOP_SESSION

https://www.youtube.com/watch?v=5n_rl9jWUMo
https://unix.stackexchange.com/questions/491161/does-an-x-client-necessarily-need-a-window-manager-to-work
https://unix.stackexchange.com/questions/20385/windows-managers-vs-login-managers-vs-display-managers-vs-desktop-environment
=========================================================================================================
                                    Greeter
=========================================================================================================
A greeter is a graphical login interface, also often called the login screen. It is provided by system`s
Display Manager. DM is responsible for starting graphics server, after that, it presents the greeter. If
the greeter can`t be started for some reason, such as misconfiguration, you won`t be able to log into
your system graphically.
By default greeters are hold in /usr/share/xgreeters/*
To change defaul greeter create /etc/lightdm/lightdm.conf and add
[SeatDefaults]
greeter-session=<wanted_greeter_cmd>

To troubleshoot related issues, enable debugging within /etc/lightdm/lightdm-webkit2-greeter.conf, now
there will be log in /var/log/lightdm/seat-0-greeter.log. Otherwise you can look at journalctl
As well try to execute greater for shell, some critical errors will be loged to terminal

https://github.com/NoiSek/Aether
https://askubuntu.com/questions/75755/how-to-change-the-lightdm-theme-greeter
https://askubuntu.com/questions/1027145/what-is-the-greeter
=========================================================================================================
                                      Xorg
=========================================================================================================
Usually refers to xorg server which is free open-source implementation of the display server for X Window
System. Implementations of the client side of the protocol are available e.g. in the form of Xlib and XCB.
Xorg uses tty7 for initialization purposes, it represents physical terminal from which you have loged in.

=========================================================================================================
                                 Scipts/Configs
=========================================================================================================
startx => script executed after logging in, provides nicer user interface for running single session of
the X Window Syste. It is a fronend for  xinit which will look for .xinitrc file.  /usr/X11R6/lib/X11/xinit
In Ubuntu Lightdm does what Startx does (does it mean that startx is not used?). If you disable lightdm,
on next boot you will log into shell, from which you can call startx or just start LightDm

xinit => utility that start server and a first client on systems that is not using a display manager.
By default it will look for /etc/X11/xinit/xserverrc configuration file to start server?. As well it looks
for .xinitrc, shell script that starts GUI part of a session by setting GUI-related settings such as key
bindings, X resources ... and launch session manager or a window manager.
Main purpose of .xinitrc is to define which X client will be used for each user after calling startx or
xinit. If ther is no ~/.xinitrc, startx will look for it in /etc/X11 but xinit wount (look man).
Typically looks like
if [ -d /etc/X11/xinit/xinitrc.d ]; then
  for f in /etc/X11/xinit/xinitrc.d/*; do
    [ -x "$f" ] && . "$f"
  done
  unset f
fi
exec i3

.xprofile => config like .profile or .bash_profile but is issue by display manager (beginning of the X user
session - before the window manager is started). Some DMs source it by default otherwise you can specify
it from xstart/xinit (Seems that it is only for GDM)

.xserverrc => shell script responsible for starting up the X server. Both start and xinit execute
~/.xserverrc if iy exists, startx use /etc/X11/xinit/xserverrc otheriwise

.xsession => executed by DM when user logs in to set system variables and start gui session (execute
.xinitrc). Typically it is sourced by old WM but new ones give you an option, you specify custom in DM
then this script will be executed, start wanted WM. It is kind of alternative to shell .profile, since
you have loged with DM and .profile was not sourced but you may still need some global variables/configurations
therfore you have this file. /etc/X11/Xsession is executed always by DM? Global Xseesion may have Xsession.d
where will be file like, 40x11-common_xsessionrc which tries to read ~/.xsessionrc (on Debian at least).
.xsession will be read from script 99x11-common_start. and is meant for running the session manager.
Typically looks like
#!/bin/sh
. ~/.profile
. ~/.xinitrc

.xsessionrc => file issued by one of /etc/X11/Xsession.d scripts, which holds global environment variables.
It is read before .xsession therefore any environment variables are available for aplications started
from .xsession. It is .xinitrc fallback for startx.

xinitc => client script, runs many programs in the background
xserverrc => server to run, the default is X

        User ====> startx  =====\
                  (script)       \
   init   =====>  lightDm  =====> xinit  =====>
(systemd)           (DM)         (script)

    lightDm ===> .xsession
      \========> .xprofile
      \========> xinit

    xinit ===> .xinitrc => starts window manager
     \=======> .xserverrc => start xorg server
https://www.sitepoint.com/understanding-nix-login-scripts/
https://unix.stackexchange.com/questions/281858/difference-between-xinitrc-xsession-and-xsessionrc
=========================================================================================================
To find window id by process pid use
xdotool search --pid <pid>

To dump window tree structure use
xwininfo -root -tree
=========================================================================================================
To study
nvidia troubleshooting
https://askubuntu.com/questions/1244376/cant-get-internal-and-external-monitor-working-simultaneously-with-20-04-on-lap
https://jichu4n.com/posts/how-x-window-managers-work-and-how-to-write-one-part-ii/
=========================================================================================================
