=========================================================================================================
                                      Git
=========================================================================================================
                                 Debug options
---------------------------------------------------------------------------------------------------------
GIT_CURL_VERBOSE=1                         # use these before as prefix to cmd
GIT_TRACE=1                                # being issued
GIT_TRACE_PACKET=1
GIT_REFLOG_ACTION="<description>" <intf>   # description displayed in reflog

GIT_CURL_VERBOSE=1 GIT_TRACE=1 GIT_TRACE_PACKET=1 
=========================================================================================================
                                    Refspec
=========================================================================================================
Local branches are mapped to remite ones with a special syntax called `refspec`, that takes the form
<source>:<destination>. Here, <source> is a branch that exists on a remote repository, while <destination>
is the branch it should map to in the local repo.

Example of refspec may look like `fetch: +refs/heads/master:refs/remotes/origin/master`, meaning that
next time we fetch, git will update local master from remote one. The `+` tells git to perform a merge
if no fast-forwarding is appropriate during a fetch.

Aother example `fetch = +refs/pull/*/head:refs/pull/origin/*` would create a local branch for each
pull request in repo on a fetch.

https://stackoverflow.com/questions/44333437/git-what-is-refspec
https://stackoverflow.com/questions/47814644/how-to-understand-remote-origin-fetch-setting-in-git-conf-file
=========================================================================================================
                                    Branches
=========================================================================================================
Branch. Active parallel line of development, usefull for isolation and separation different types of work.
A single repository can have an arbitrary numer of branches.

There are next types of brnaches:
# Branches on local machine. To list local branches issue `git branch`
1. Non-tracking local branch
   Standalone branches not associated with any other branches, newly crated branches with `git branch <name>`
2. Local-tracking branch
   Branch associated with remote tracking branch. Word tracking means when you push/pull on that branch,
   git knows which remote branch to get changes from or push to during push/pull. This will affect your
   `git status`. Since now it will know about difference between local and remote state, it will say
   that you HEAD is behind or ahead of remote.
   To list local tracking/nontracking branches issue `git branch -vv`
       <name> <hash> [optional tracking branch]
       * master d758bbb [origin/master] Merge th_% and % files in one, update readme
   From previous output you can see that there is a local branch master pointing to remote one origin/master

   You can create a new branch and make it track another with `git branch --track <new_branch> <to_track>`.
   You can use shorter command if your local name is the same as remote one, like
   git checkout --track <remote>/<branch>         # creates local tracking branch <branch>
   git checkout -b <local> <remote>/<branch>      # creates local tracking branch <local> pointing to <branch>
   git branch --set-upstream-to=<to_track> <local_branch> # updates already created branch
   git branch --unset-upstream                    # stops tracking

3. Remote tracking branch
   References to the state of branches in yout remote machines. You can`t move them but can update with
   `git fetch`. This one has form of <remote>/<branch>. You can list them with `git branch -r`

Branches on remote machine:
1. Remote branch. It is a branch located on a remote machine/server. You can view all the remote branches
   with `git remote show <remote>` or `git ls-remote --heads <remote>`

Default branch. Usually - master. Considered the base branch in your repository, against which all pull
requests and code commits are automatically made unless you specify a different branch. Note that this
applies only to GitHub and not git. This way people will, by default, clone branch defined by you, and
upstream will be the same branch? but this doesn`t stop you from commiting into master.
There is option to set hooks with permisions on branch therefore, you can specify who can change branch
and who don`t.

When you pull like `git pull origin master`, chages from master will be pulled into whichever branch is
currently checked out.
?? How git knows where to fetch data from and which exect branch to track

When you create/checkout a new branch, your config file will change. Additional section that configures
the branch is added. It looks like following
[branch "master"]
    remote = origin
    merge = refs/heads/master
Here `remote` 

http://gitready.com/beginner/2009/03/09/remote-tracking-branches.html
https://stackoverflow.com/questions/4693588/what-is-a-tracking-branch
https://dzone.com/articles/git-differences-between-local-branch-non-tracking-1
https://help.github.com/en/articles/setting-the-default-branch
---------------------------------------------------------------------------------------------------------
                               Comparing branches
---------------------------------------------------------------------------------------------------------
You can look which commits are present on one branch and abscent on another using `show-branch`
    git show-branch feature_branch master origin/master
This can be used to find the closest common commit between them.

Another thing that you can do is taking diff between HEAD of branches
git diff <branch_a>..<branch_b>

git-merge-base - Find as good common ancestors as possible for a merge

https://thoughtbot.com/blog/compare-commits-between-git-branches
---------------------------------------------------------------------------------------------------------
git push <remote> <branch_name>                             # push branch to remote 
                                                              local branch has the same name as remote
git push origin <local_branch>:<branch_on_remote>
git branch --set-upstream my_branch origin/origin_branch    # set upstream branch
            -u <remote> <branch>                            # -u is short for set-upstream
            -d <branch_name>                                # delete branch name
            -b <branch_name>                                # create and checkout branch
           --contains <commit>                              # will show all branches containing commit
                                                              not very usefull if commit`s already been merged
            -r                                              # list branches on the remote
            -a                                              # list all (local?) branches
            -m <newname>                                    # rename current branch
            -m <oldname> <newname>                          # rename any branch

=========================================================================================================
                                     Remote
=========================================================================================================
Remote. The remote version, which is mostly use for archiving, collaboration, sharing, and CI triggers.
Usually, whenever you read “repo” or “Git repo”, it’s your local, interactive repo (that is, with a working
directory alongside its .git root).

git remote add  <remote_name> <location>          # adds remote to your local repo
                               git@github.com:User/UserRepo.git
                               http://host/path/to/repo.git
                               ssh://user@host/path/to/repo.gi
                               <local_path>/git_repo/
git remote set-url <local_remote> <location>      # change local remote to point to <location>
                                                  # fails if there is no <local_remote>
git remote rename <old_name> <new_name>           # rename without changing <location>
git remote -v                                     # list remotes

Under the hood, `git remote add` changes your `.git/config`, therefore there is no need to call `git` and
you can edit file mannualy, but using command is more convinient. Changes looks like following
[remote <name>]
    url = <location>
    fetch = ...
Here, `url` says where repo is living and `fetch` configures hot the `fetch/pull` commands handle retrieving
information from the <name> remote.

For more information look into `man git-config`

https://dev.to/jessachandler/explain-git-config-like-im-five-750
=========================================================================================================
                                      Push
=========================================================================================================
                                   Force push
---------------------------------------------------------------------------------------------------------
When you push changes to a remote server, Git prevents you from pushing your changes if the remote has
changes you’re missing. This feature is designed to prevent data loss. Usually what you need to do
is just pulling before push.
A force push overwrites a remote branch with yout local branch, regardless of the status of that remote
branch. This may result in the scenarion when one developer doesn`t fetch before force pushing, therefore
overwriting other developer`s commits.

What are the situations where we can`t push without force?
1. Pushing changes to remote without pull before
2. Changing history with squshing/fixuping and then pushing.
3. You want to remove sensitive data from history
4. You have ammended already pushed commit
5. You reset HEAD instead of reverting

If you’re working on a team and need to rebase a shared branch, here are the steps:
1. Make sure your team has committed and pushed any pending changes
2. Ask your team to pause work on that branch temporarily
3. Make sure you have the latest changes for that branch (git pull)
4. Rebase, then git push origin <yourbranch> -f
5. Have your team fix up their local branches with
   git checkout <yourbranch>,
   git fetch
   git reset --hard origin/<yourbranch>

Before force pushing, fetch changes and apply them to your tree, otherwise you will overwrite them.
Note, there still may be a race condition if somebody pushes changes between when you fetch and you push,
you may still overwrite them. To avoid this, communicate with your team.

Force-with-lease (safer alternative). Let`s you change the history, but will stop if there are some new
commits on the remote branch.

https://willi.am/blog/2014/08/12/the-dark-side-of-the-force-push/
---------------------------------------------------------------------------------------------------------
                           Recovering from force push
---------------------------------------------------------------------------------------------------------
In case you missused `push -f` you may have copule solutions to fix the situation. 

Best case scenario: someone else who is working on the same code pulled a recent version of the master just
before you broke it. Then all you have to do is to go into your team’s chat and ask that person to force
push their recent changes. If you are lucky, their local repository will have the full history of commits,
your mistake will be overwritten with fresh code, and nothing will be lost.

Case 1: You were the last person to push to master before the mistake. In such case you need to force
push last valid commit to master. HEAD transition is displayed to terminal after push.
 + deadbeef...f00f00ba master -> master (forced update)     # transition
 git push --force origin deadbeef:master                    # push last valid commit

Case 2: Someone else pushed before you have messed up. In this case you should open feed display on the
GitHub, then open hash of the last good commit and make a branch from it. Now you can fetch that branch
and force push it as main.
git fetch git push --force origin origin/master-before-force-push:master

? Why can`t we ask him to force push
? What if he has not full history for the repo

https://evilmartians.com/chronicles/git-push---force-and-how-to-deal-with-it
---------------------------------------------------------------------------------------------------------
=========================================================================================================
                               Renaming detection
=========================================================================================================
You should commit any changes, perform rename and then stage you renamed file? Git will recognize the
file from contents, rather than seeing it as a new untracked file, and keep the changed history.

? How does git compare file content, calculates and compares hash ?

=========================================================================================================
                                    Fetching
=========================================================================================================
Fetch. Operation of downloading changes (newer/older) from a remote server. When you clone your project,
it automatically gets remote-tracking master branch. After that, git tries to checkout your local master,
however it is not present, therefore git guess that you wanted to make a new local branch `master` pointing
to remote `master`. This provides git with location information about where it should get changes from.
Remote branch is called an upstream.

git fetch <remote> <remote_branch>:<local_branch>           # fetch branch from remote into local non existing branch
git checkout <local_branch>                                 # short form of previous solution
git checkout -b <local_branch> <remote>/<remote_branch>     # fetche remote branch and make local branch
                                                              point to remote one.
git checkout --track <remote>/<branch>                      # the same as previous but shorter

https://stackoverflow.com/questions/37770467/why-do-i-have-to-git-push-set-upstream-origin-branch/37770744
=========================================================================================================
                                    Applying
=========================================================================================================
git apply --check                   # dry run
git apply --reject                  # apply any valid hunks and save rejected to *.rej files
          --directiry="prefix/"     # add prefix directory when applying patches with different root path

If git apply makes no output, and changes are not applied, try -v flag. If there is no output as well
check paths used during patch creating and try applying from another directory.

If you need to apply big patch, and it fails on many hunks, you can use -3 (--3way) flag to merge conficts
by hand after applying.

https://www.drupal.org/node/1129120
---------------------------------------------------------------------------------------------------------
                                      Show
---------------------------------------------------------------------------------------------------------
git show --pretty="" --name-only commitHash -> lists commited files
git show #commithash
git show <hash>:<file>      # look at file at specific commit

---------------------------------------------------------------------------------------------------------
                                Unstaged changes
---------------------------------------------------------------------------------------------------------
git clean
          -n        # display which files will be cleaned
          -f        # remove unstaged files
          -f <flag> # force
          -f -d     # delete unstaged directories
          -f -X     # delete unstaged ignored file?
          -f -x     # delete unstaged ignored and non-ignored files?

git trash
=========================================================================================================
                                      Tags
=========================================================================================================
git tag -a <tag> <hash> -m "Create tag ..."       # set tag for specific commit, if hash is not defined
                                                    last commit will be tagged
git push --tags                                   # push tags

git tag -l | xargs git tag -d && git fetch -t     # delete local(all) unpushed tags
git push --delete <origin> <tag>                  # delete tag remotly
git push <remote> :<tag>                          #
                                                  ! NOTE don`t forget do delete locally
git tag -d <name>                                 # delete tag locally

git tag -l -n<count> [tag_regex_name?]            # print tags with description message
git tag -l --points-at <hash>                     # list tags pointing to commit
git rev-parse <tag>^{}                            # to get hash of tagged commit
              <tag>{}                             # to get hash of tag
              -d <tag>                            # to get hash of both

---------------------------------------------------------------------------------------------------------
                                 Updating tags
---------------------------------------------------------------------------------------------------------
https://stackoverflow.com/questions/7813194/how-do-i-edit-an-existing-tag-message-in-git
git tag <tag> <tag>^{} -f -m "<new message>"      # replace tag message
                       -f -a                      # opens editor for message
---------------------------------------------------------------------------------------------------------
                                Replace tag flow
---------------------------------------------------------------------------------------------------------
git tag <new_tag> <old_tag>                 # create new tag aliasing old one
git tag -d <old_tag>                        # delete locally old
git push <remote> :refs/tags/<old_tag>      # delete remotely
git push --tags

annotated tags?
unshallow ?
---------------------------------------------------------------------------------------------------------
                  To list unpushed tags issue one of the next
---------------------------------------------------------------------------------------------------------
git show-ref --tags | grep -v -F "$(git ls-remote --tags <remote name> | grep -v '\^{}' | cut -f 2)"
git push --tags --dry-run           # -n can be used instead of --dry-run (requires to have permisions
                                      for remote)

=========================================================================================================
                                     Config
=========================================================================================================
There are 3 levels of git config; project, global and system.
1. Project. Project configs are only available for the current project and stored in .git/config in the
   project's directory.
2. Global. Global configs are available for all projects for the current user and stored in ~/.gitconfig.
3. System. System configs are available for all the users/projects and stored in /etc/gitconfig.

Options can be changed with `git config <options>` or by editing configuration files.
By default, `git config` modifies .git/config, not ~/.gitconfig, latter is modified only with --global.
git config user.name "John Doe" 
git config --global user.name "John Doe"
git config --system user.name "John Doe"

As well, there are conditional configuration includes, e.g. add following to your ~/.gitconfig:
[includeIf "gitdir:~/proj1/"]
  path = .gitconfig-proj1
[includeIf "gitdir:~/proj2/"]
  path = .gitconfig-proj2

https://stackoverflow.com/questions/8801729/is-it-possible-to-have-different-git-config-for-different-projects
=========================================================================================================
                                     Status
=========================================================================================================
git status
         -u\--untracked-files=[all,no,normal]  # filter untracked files in status
                          normal               # doesnt show files of untracked directories
                          all                  # show files within untracked directories
                                               # status.showuntrackedfiles for configuration purpose
                                               # Note, value should stick to short version, -u[all/no...]


git ls-tree -r <HEAD|Branch> --full-tree  --name-only     # list tracked files on that branch

List ever existed, tracked files
git log --pretty=format: --name-only --diff-filter=A | sort - | sed '/^$/d'

To force colorfull output to files and pipes, you can define color.status variable as following
git -c color.status=always status 
The same for diff/show/log
git -c color.ui=always diff

https://unix.stackexchange.com/questions/44266/how-to-colorize-output-of-git
=========================================================================================================
                                     Ignore
=========================================================================================================
These explanations assume your .gitignore file is in the top level directory of your repository, as is the
convention. If file is somewhere lower within tree, it works only for it subtree.

**/dir          | exclude <dir> anywhere within tree
**/parent/dir   | consider parent
*.ext           | any files with extensioj
!spec_file.ext  | reinclude specific file
/name           | match only in root
name            | match in any directory
                | if <name> == directory name, directory is excluded
debug[0-9].log  | match a single character from a specified range
debug[01].log   | match a single character form the specified set
debug[!01].loga | match any character except one from the specified set
debug[a-z].log  | ranges can be numeric or alphabetic
path/**/*.log   | double asterisk matches zero or more directories

You can use # to comment, but you need to escape patterns with \
# ignore the file literally named foo[01].txt foo\[01\].txt 

You can have global git ignore file
  $ git config --global core.excludesFile ~/.gitignore 

git ls-files . --ignored --exclude-standard --others  # list ignored files
             . --exclude-standard --others            # list untracked files
git stash with the --all              # stash even ignored files
git check-ignore -v <file>            # shows the rule which hides the file

https://git-scm.com/docs/gitignore
https://github.com/github/gitignore
https://stackoverflow.com/questions/3538144/how-do-you-git-show-untracked-files-that-do-not-exist-in-gitignore
=========================================================================================================
                                      Logs
=========================================================================================================
git log --author=Smith
        --diff-filter=A                 # commit when file was added
        --follow -- filename            #  -- all commits touching file 
        --pretty=oneline                # hash + commit in 1 line
        --pretty=fuller                 # by default git log displays date when commit was made locally
                                          but not when pushed, this option display both timestamps
        --abbrev-commit --pretty=oneline     # short hash + commit in 1 line
        --merges <commit>..                  # to see merge commits that have the given commit as an ancestor.
        --oneline --decorate  --all --graph
        --graph --oneline --all
        --since=1.month
        --author
git shortlog                            # commit message + empty line + summary

git log -S<word> -- path                # find commit where word was added or removed but not moved
        -G<wold> -- path                # find commit adding, removing or moving regex
            --since=<date> --untill=<date>

Files history
git log --stat #hash                    # files + some stats
        --name                          # name only
        --name-status                   # name + status (one letter abriviation)

git grep -n ‘log_syslog’ v1.5.3.8 v1.0.0 -- *.c

---------------------------------------------------------------------------------------------------------
                                     Reflog
---------------------------------------------------------------------------------------------------------
git reflog                                   # create a branch for deleted commit so it won`t be cleaned 
git reflog show --all | grep <commit_hash>   # can be use to find first occurence of commit

=========================================================================================================
                                     Blame
=========================================================================================================
                                    Pickaxe
---------------------------------------------------------------------------------------------------------
The problem of blame is showing the latest syntactic change instead of semantic, therefore if you will try
to fix code formation, instead of seeing who last has changed line semantics, you see who last changed a
lines` content.
The soultion for this is a git pickaxe, which is a `-S` flag of git log. This option takes an argument,
a line that is looked through commit history for ones changing it.

git log -S 'return'     # will display all commits who added/removed/changed line containing a `return`
        -G 'stmt'       # supports regex
            -p          # will display patch instead of metadat
        --all           # search over all branches and tags
        --branches=<pattern>
        --tags=<pattern>
        --grep="<text>" # all commits have <text> in commit message

https://stackoverflow.com/questions/4468361/search-all-of-git-history-for-a-string
https://remireuvekamp.nl/blog/the-git-pickaxe.html
=========================================================================================================
                                    Merging
=========================================================================================================
Fast-forward merge, can be used when ther is not diverge between branches that want to merge. This will
just move branch head to merged branch head. Note, there will be no history showing that this merge has
occured, if you want to save it there is special flag.

Three-Way merge, occurs when there is dirverge between branches. This merge creates an extra commit to tie
together the two branches.

When merge occurs, diverged hunks will be outlined with 
<<<<<<<<<<<<< Conflict marker, conflict starts here
============= Divider, divides changes done by commits
>>>>>>>>>>>>> End of confilct

https://dev.to/neshaz/how-to-use-git-merge-the-correctway-25pd
---------------------------------------------------------------------------------------------------------
                                 Merge history
---------------------------------------------------------------------------------------------------------
git diff-tree -cc <hash>    # to see merge resolving
                            #or maybe -c ?
---------------------------------------------------------------------------------------------------------
                                Merge vs Rebase
---------------------------------------------------------------------------------------------------------

=========================================================================================================
                                   Reverting
=========================================================================================================
git revert <commit_range/list>    # revert already pushed commits 
           <sha>..HEAD            # HEAD is taken inclusively

If you want to revert multiple commits as one (otherwise each revert is made in separate commit),
use --no-commit flag.
git revert --no-commit <commit_range/list>
git commit -m 'Reverted range of commits'

---------------------------------------------------------------------------------------------------------
                             Alternative solutions:
---------------------------------------------------------------------------------------------------------
checkout contents of older commit, and commit this state
git checkout -f HEAD~<n> -- .
git commit -a
This would create additional commit, with changes returning current state of repo to older one and commiting
it above.
---------------------------------------------------------------------------------------------------------
Take reverse diff and apply it
git diff HEAD <old_sha> | git apply
---------------------------------------------------------------------------------------------------------

Sometimes, you can avoid rever and use rebase but it has side effect of changing hisoty of repo, making
work of other users based on this history inalid (you have rewrited part of history on which another work
was based). As well, it may create problems with merging and other operations depending on repos history.


https://stackoverflow.com/questions/1463340/how-to-revert-multiple-git-commits
=========================================================================================================
                                     Reset
=========================================================================================================
git reset HEAD^        -- moves head to a specific commit (doesnt remove changes)
        --hard
        --soft
git checkout file : to clean file from chages since commit

=========================================================================================================
                                     Bisect
=========================================================================================================
When you don`t know which commit introduced a bug, use `git bisect` to find the bad commit quickly via a
binary search algorithm.
git bisect start            # starts a search process
git bisect bad  HEAD        # start of the range
git bisect good <commit>    # end of the range
This set of commadns will checkout commit in the middle of the range and let you to check.
Now you can keep spliting ranges with `git bisect good/bad`
Onee, you have found the bug, clean up and return to the original HEAD
git bisect reset

It is possible to run bisect with a script
https://www.tygertec.com/find-stuff-git/
=========================================================================================================
                                      Grep
=========================================================================================================
The main difference between your system wide grep and git grep is that git grep looks only at tracked
files. Another feature of git grep is that it has option to grep through repository at certain commit state.
git grep foo HEAD^
git grep -e <regexp> my_other_branch -- '*.js'

It has more ways of commbining patterns you are looking for
git grep -e pattern1 --and --not \( -e pattern2 -e pattern3 \)
git grep pattern -- '*.[ch]

https://travisjeffery.com/b/2012/02/search-a-git-repo-like-a-ninja/
=========================================================================================================
                                   Submodules
=========================================================================================================
Submodules, like subtrees, aim to reuse code from another repo somewhere inside your own repo’s tree.
The goal is usually to benefit from central maintenance of the reused code across a number of container
repos, without having to resort to clumsy, unreliable copy-pasting.
Submodules rely on nesting repos: you have repos within… repos. The module has its own repo, somewhere
inside the working directory of its container repo.
Submodules use a simple .git file with a single gitdir: line mentioning a relative path to the actual repo
folder, now located inside the container’s .git/modules.

There are a number of situations where the physical presence of module code inside container code is mandated,
usually because of the technology or framework being used. For instance, themes and plugins for Wordpress,
Magento, etc. are often de facto installed by their mere presence at conventional locations inside the
project tree, and this is the only way to “install” them.

Submodules are the right choice when your codebase is massive and you don’t want to have to fetch it all
every time, a situation many tentacular code bases grapple with. You then resort to submodules so your
collaborators don’t necessarily have to fetch entire blocks of the code base.

You should strive for submodule code to remain independent of particularities of the container
(or at least, rely on external configuration to handle such particularities), as submodule code is central
code, shared across all container projects.

---------------------------------------------------------------------------------------------------------
Disadvantages:
- Every time you add a submodule, change its remote’s URL, or change the referenced commit for it, you
  demand a manual update by every collaborator
- Forgetting this explicit update can result in silent regressions of the submodule’s referenced commit.
- Commands such as status and diff display precious little info about submodules by default.
- Because lifecycles are separate, updating a submodule inside its container project requires two commits
  and two pushes.
- Submodule heads are generally detached, so any local update requires various preparatory actions to
  avoid creating a lost commit.
- Removing a submodule requires several commands and tweaks, some of which are manual and unassisted.
- You need to know what you`re doing
---------------------------------------------------------------------------------------------------------

git submodele add ../mainmod.git submod
git submodule update
git pull --recurse-submodules --jobs=10
git submodule update --recursive --remote

git clone
git submodule init
git submodule update
                     --init               # to avoid separate init command
git clone --recursive remotes/main local  # to avoid init&update
https://medium.com/@porteneuve/mastering-git-submodules-34c65e940407
=========================================================================================================
                                    Stashing
=========================================================================================================
git stash                           # stash changes
git stash list                      # list stashes
git stash apply                     # apply last stash
git stash apply stash@{#}           # apply specific stash
git stash show -p                   # show stashed content in patch form
git stash show -p stash@{any}       # show specific stash in patch form

=========================================================================================================
                                    Rebasing
=========================================================================================================
git rebase <destination>     # chage <current branch> base commit to point for <dst>
git rebase -i                # rebase for all unpushed commits
git rebase -i HEAD~5         # redo content/msg of last local commits
            fixup            # clears commit message and merge content
            squash           # merger changes and lets you to give new commit message

Preferring current branch changes during merge conflicts
git rebase -Xtheirs <branch>
           -Xours

It is reversed for git merge
git merge -Xours origin/master  # to leave your changes over master

Note, squashing/fixup will alter your history which may be a problem if somebody based their job on a
commit you have removed.

---------------------------------------------------------------------------------------------------------
                                     Clean
---------------------------------------------------------------------------------------------------------
git clean           # remove untracked files and directories
            -f      # force, is required if clean.requireForce == true
            -d      # remove directories as well
            -i      # interactive
            -n      # dry run
            -x      # remove ignored files

https://stackoverflow.com/questions/61212/how-to-remove-local-untracked-files-from-the-current-git-working-tree
=========================================================================================================
                                   Commiting
=========================================================================================================
git commit --amend --no-edit        # don`t open commit form 
           -m "message"             # specify new message
           --athor                  # use custom author tag, usually "initias <email>"

=========================================================================================================
                                     Diffs
=========================================================================================================

git diff --no-index <file1.txt> <file2.txt>           # diff on non git files
git diff --staged                                     # same to git diff HEAD
patch -p1 < patch.diff                                # apply patch, remove first dir from paths in patch

To take diff for all file of one type issue `git diff -- '*.c' '*.h'` or if you want it to be recursive
shopt -s globstar; git diff -- *.py **/*.py

You can take diff between HEADs of different branches like follows
git diff <branch_a>..<branch_b>
git diff master..development

diff -rq            #
     --brief        # list fils that are different without content
     -N             # list file that is present in 1 dir but not other


https://stackoverflow.com/questions/8554776/how-to-filter-git-diff-based-on-file-extensions
---------------------------------------------------------------------------------------------------------
                          Diff strategies(algorithms)
---------------------------------------------------------------------------------------------------------
There are 4 different diff strategies: myer, patience, histogram and minimal.
1. Myer. The default mode that is used when taking diff, it is faster then others but quality isn`t the best.
2. Patience. The first implementation of quality oriented diff.
3. Histogram. Version implemented by jgit project that is supposed to be both fast and provide decent quality.
4. Minimal. Extension of myer, which will perform for some predefined CPU time and then return the best
   (smallest) diff it made.

To define one algorithm by default there is configuration variable diff.algorithm that can be one of the
    'myers' 'minimal' 'patience' 'histogram'.

It is possible to use external diff engine by defining GIT_EXTERNAL_DIFF

https://stackoverflow.com/questions/19949526/examples-of-different-results-produced-by-the-standard-myers-minimal-patienc
https://fabiensanglard.net/git_code_review/diff.php
https://stackoverflow.com/questions/32365271/whats-the-difference-between-git-diff-patience-and-git-diff-histogram
---------------------------------------------------------------------------------------------------------
                                    vimdiff
---------------------------------------------------------------------------------------------------------
If you want to view difference between file and patch (like you would apply patch and check diff), issue
  vim <file>
  :vertical diffpatch <diff_path>
or
  vim file +'vert diffpatch <diff_path>'
This is equivalent to calling vimdiff on original and patched file, but vim calls patch on a temporary
file for you. If patch applies to another files as well, diff will give you choise to skip them.

Hotkeys for vimdiff
do      # get changes from other window into current (dg?)
dp      # put the changes from current window into the other window
]c      # jump to the next change
[c      # jump to the previous change

:diffup     | recolor diff


https://stackoverflow.com/questions/242646/use-vimdiff-with-a-diff-file
---------------------------------------------------------------------------------------------------------
                                      Gui
---------------------------------------------------------------------------------------------------------
gitk
git instaweb --httpd=webrick

---------------------------------------------------------------------------------------------------------
                                    diffall
---------------------------------------------------------------------------------------------------------
git-diffall : open all diffs at once
git diffall rev1..rev2

#!/bin/sh
git diff --name-only "$@" | while read filename; do
    git difftool "$@" --no-prompt "$filename" &
done
=========================================================================================================
                                Low level-staff
=========================================================================================================
git rev-parse HEAD          : returns hash of HEAD
git cat-file commit HEAD        : returns hash of tree + additional info like author and comiter
             -t HEAD    : shows type of object
             -p <object>    : instructs the command to first figure out the type of content, then display it appropriately
git ls-tree #commit         : get hash for tree of commit
git ls-tree #hash           : shows what files tree references
git hash-object <object>        : adds object to objects/ and prints hash
git write-tree              : write the staging area out to a tree object
GIT_CURL_VERBOSE            : to show curl flow
GIT_REFLOG_ACTION  <git operation>  : to add comment into reflog for operation
---------------------------------------------------------------------------------------------------------
                             Restore file by commit
---------------------------------------------------------------------------------------------------------
git reset <hash> <filename>
git checkout <hash> -- <filename>       # will change local file
git show <hash>:<file> > <new_file>     # save file state to <new_file>

=========================================================================================================
                                Clone and Fetch
=========================================================================================================
To get your local copy of remote repository issue `git clone <url>`, which by default will get full copy
of specified branch (master by default?) and metadata for other branches (saved under .git). However, such
version may include huge history which you may don`t need for your use case. To overcome this issue, you
can have partial/shallow copy. There are two types of partial clone.
1. Shallow clone, has all changes from last revision, you define depth of history you want to have using
   `git clone --depth=<number> <url>`. Note that this depth is applied for all branches and they may become
   orphaned (no shared parent). In case of orphaned branches, it is not allowed to performe merge/rebase
   since there is no common ancestor. It is possible to perform pull/push on such repos, since you have
   tip of branch.
2. Sparce clone, has subset of features from repository, defined by filter.

If you want full copy or remote with all branches and their history, use --bare option.
If you want to make full clone from shallow clone, issue 
git fetch
      --unshallow
      --shallow-since=day/month/year
      --deepen=<depth>                 # incremental one, number of commits from the current shallow
                                         boundary instead of from the tip of each remote branch history
                                         Note, this by default assumes --single-branch flag but can be
                                         overriden with --no-single-branch
      --update-shllow
      --depth=1000000000               # literally download all commits and tags(?) from repo
      --tags/--no-tags                 # by default tags that points into the history being fetched are
                                         also fetched.

      --single-branch

git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
git fetch origin
---------------------------------------------------------------------------------------------------------
                                   FETCH_HEAD
---------------------------------------------------------------------------------------------------------
Short lived ref(?), to keep track of what has just benn fetched from the remote repo. It points to the tip
of new fetched branch. Git pull merges FETCH_HEAD into active branch. It`s value is saved under
.git/FETCH_HEAD

---------------------------------------------------------------------------------------------------------
                            Cloning part of project
---------------------------------------------------------------------------------------------------------
git clone sparse # still downloads all history but lets to checkout only part of project
git clone --filter

https://unix.stackexchange.com/questions/233327/is-it-possible-to-clone-only-part-of-a-git-project
---------------------------------------------------------------------------------------------------------
https://stackoverflow.com/questions/42906152/git-clone-by-default-shallow-or-not
=========================================================================================================
                                  Cherry-pick
=========================================================================================================

Cherry-pick from another repository
git remote add <name> <path>
git fetch <name>
git log <name>/<branch>
git cherry-picl <sha>

https://stackoverflow.com/questions/5120038/is-it-possible-to-cherry-pick-a-commit-from-another-git-repository
https://coderwall.com/p/sgpksw/git-cherry-pick-from-another-repository
=========================================================================================================
                                   File modes
=========================================================================================================
Git maintains a special `mode` for each file in its internal storage. This can be visualized using
git ls-files --stage

By default, when you add a file to a repository, Git will try to honor its filesystem attributes and set
the correct filemode accordingly. You can disable this by setting core.fileMode option to false:
git config core.fileMode false

It can be changes using 
git update-index --chmod=+x path/to/file
git add --chmod=+x path/to/file

In Git, file permissions are recorded only as either 644 or 755, where 644 means that the file should not
be executable, and the latter means that it should be executable

https://stackoverflow.com/questions/40978921/how-to-add-chmod-permissions-to-file-in-git/40979016
=========================================================================================================
                                     Links
=========================================================================================================
Git won`t cross symbolic linked directories. There are a couple of workarounds,
1. You can mv wanted directory to git, and create link at original position (won`t help if you want link
   directory into multiple git repos)
2. There is a GitBLSR repo, which provides reworked logic for symlinck check mechanism, you just prelod
   it with LD_PRELOAD
        alias git="LD_PRELOAD=/path/to/gitbslr.so git"
3. You can use bind mount
4. Change git working tree for the specific actions. (Not sure how it works or supposed to work?)
        git --work-tree=/home/project/ add /home/static/
        git --work-tree=/home/project/ commit /home/static/

https://superuser.com/questions/174833/how-can-i-make-git-commit-files-in-a-symlinked-folder
=========================================================================================================
                               Special characters
=========================================================================================================
HEAD => points to last commit in repo
@ => alias for HEAD, can be like
git diff HEAD~ HEAD  == git diff @~ @

=========================================================================================================
                          Rules for making good commit
=========================================================================================================
Why is this change necessary?
How does it address the issue? (describe at high level what was fone to affect change)
What side effects does this change have?


Write your commit message in the imperative: "Fix bug" and not "Fixed bug" or "Fixes bug."
# 50-character subject line
#
# 72-character wrapped longer description. This should answer:
#
# * Why was this change necessary?
# * How does it address the problem?
# * Are there any side effects?
#
# Include a link to the ticket, if any.
=========================================================================================================
                                      Misc
---------------------------------------------------------------------------------------------------------
wget --no-check-certificate --content-disposition https://URL-RAW   # download one file
curl -LJO                                                           #

=========================================================================================================
                                    Amending
=========================================================================================================
To change commit msg or merge currently staged objects to your last local commit, from directory with
repository issue (commit window will popup)

git commit --amend
git commit --amend --no-edit     # if you don`t want to change commit message
git commit --amend -c <hash>     # ammend specific commit
=========================================================================================================
                                     Index
=========================================================================================================
                             stage/
             add             commit                 push
workspace ==========> index ==========> local repo =========> remote repo

---------------------------------------------------------------------------------------------------------
                                  update-index
---------------------------------------------------------------------------------------------------------
You may have a file that is quite big and chages from time to time but you preatty much don`t care about
it`s content or just don`t want to check if it was changed since last commit. For example, some device
firmware or compiled libraries may be big in size therefore taking allot of time to check if they were
changed. As well, it`s content is mostly binary and not readable by human therefore you don`t care what
about changes within it, only about fact that it has changed. To avoid spending resources to check such
files you ask git to ignore them. This is done using `git update-index --assume-unchanged <file>`, to
temporarilt exclude the file from any tracking.
git update-index --assume-unchanged <file>          # ignore file tracking
git update-index --no-assume-unchanged <file>       # undo previous command
git ls-files -v                                     # list `assume-unchanged` files

This can be used to hide a file without stashing + unstashing + checking out the file to avoid it`s getting
into commit.
Following aliases may be usefull:
hide = update-index --asume-unchanged
unhide = update-index --no-asume-unchanged
hidden = ! git ls-files -v | grep '^v' | cut -c3-

https://codeclimber.net.nz/archive/2016/12/19/ignoring-files-on-git-but-just-for-a-while-with-assume-unchanged/
---------------------------------------------------------------------------------------------------------
https://stackoverflow.com/questions/3689838/whats-the-difference-between-head-working-tree-and-index-in-git
=========================================================================================================
                                   Questions
=========================================================================================================
--cached vs --staged
indent heuristics
https://git-memo.readthedocs.io/en/latest/index.html
http://www.cirosantilli.com/git-tutorial/#tag
https://news.ycombinator.com/item?id=13983085

1 --base
-2 --ours
-3 --theirs
What is refspec in git
=========================================================================================================
                                     Secret
=========================================================================================================
Sometimes, you want to hold some private data in repo, for instance ecnryption keys, database passwords,
application secret-keys and so on outside of git history. Even if repo is private, you may use some third
party applications with git. Even, if application owners are not interested in your private data, if
somebody breaks this application, he may get an access to your private data.

git-secret is a bash script to store your private data inside a git repo. Basically, it just encrypts,
using gpg, the tracked files with the public keys of all the users that you trust. So everyone of them can
decrypt these files using only their personal secret key.

=========================================================================================================
                                    Markdown
=========================================================================================================
There are many options for previewing your .md file:
- typora. Text editor with a live rendering of markdown
- grip. Server for the file preview, supports page autorefresh
- mdless. less for .md
- markdow. Convers .md into html
- remarkable. Text editor with decent GUI and life preview
- gitbook. Documenting tool

Or using some shell scripting
pandoc -s filename.md | lynx -stdin

=========================================================================================================

git update-ref -m 'mark: whatever' HEAD HEAD
git update-ref -m 'mark: another thing' refs/heads/branch branch
git update-ref -m 'mark: third thing' refs/heads/branch refs/heads/branch
